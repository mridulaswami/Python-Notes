1. reading and deleting from same query doesn't work in Mysql but runs in MS SQL SERVER.

delete from Person where not id in 
(select min(id) from Person group by email)

it will run in sql server but in mysql

2. we can use order by on count and limit for getting highest count value.

eg- select customer_name from Orders group by customer_number
order by count(order_number) desc limit 1

it will give customer_name who has highest orders.

ðŸ’¡ðŸ’¡ðŸ’¡ also always keep in mind regarding where and having clause,
we use WHERE before group by to filter the condition from FROM statement but we use condition with HAVING clause 
when we have to do the group by on that condition only.

3. usage of datediff() where we have to compare current date from previous dates for some condition.

eg- select a.id from Weather a join Weather b on datediff(a.recordDate,b.recordDate)=1
where a.temperature>b.temperature

here I have compared today with yesterday and provided the data if today's temperature is higher than yesterday's.

4. usage of IF keyword in MYSQL (more efficient)(but only for MYSQL)
 if we want to check multiple conditions in an statement then it is better to use IF instead of CASE keyword -

eg- select x,y,z,
if(x+y > z and
  x+z >y and
  y+z >x , 'Yes', 'No') 
  as triangle
 from Triangle 

here I had to find out if x,y,z can form a traingle or not , so using a case keyword may be hectic here like- 

select x,y,z,
case when x+y > z and
  x+z >y and
  y+z >x then 'Yes' else 'No'
  end as triangle
 from Triangle 

5. better to use aggregate functions for MAX,MIN Values in subqueries. 
eg- 
select MAX(num) as num from
(select num from MyNumbers group by num having count(*)=1)t

6. always keep in find while using AVG aggregate function - check for decimal points(usually upto 2 digits) which can be done using ROUND 
keyword

7. while using having clause on group by , use aggregate functions in not-selection columns and never use BETWEEN keyword in comparing dates.

eg- select p.product_id,p.product_name from Product p join Sales s on p.product_id= s.product_id group by p.product_id,p.product_name
having MIN(s.sale_date) >= '2019-01-01' and MAX(s.sale_date) <= '2019-03-31'

here I had to use min,max in dates because they weren't in select column and group by because first I have to find our product_id in sales table who haven't done any business apart from first quarter ,
which is also why product_id- 2 isn't in output.

problem - Write a solution to report the products that were only sold in the first quarter of 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.
Input: 
Product table:
+------------+--------------+------------+
| product_id | product_name | unit_price |
+------------+--------------+------------+
| 1          | S8           | 1000       |
| 2          | G4           | 800        |
| 3          | iPhone       | 1400       |
+------------+--------------+------------+
Sales table:
+-----------+------------+----------+------------+----------+-------+
| seller_id | product_id | buyer_id | sale_date  | quantity | price |
+-----------+------------+----------+------------+----------+-------+
| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |
| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |
| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |
| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |
+-----------+------------+----------+------------+----------+-------+
Output: 
+-------------+--------------+
| product_id  | product_name |
+-------------+--------------+
| 1           | S8           |
+-------------+--------------+
Explanation: 
The product with id 1 was only sold in the spring of 2019.
The product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.
The product with id 3 was sold after spring 2019.
We return only product 1 as it is the product that was only sold in the spring of 2019.

ðŸ’¡ðŸ’¡ðŸ’¡ - good question.

8. if you want particular month-year-date from full date then use postgres - date_trunc() keyword for best practises
or oracle uses - trunc()

oracle -

SELECT
    TO_CHAR(TRUNC(order_date, 'MM'), 'YYYY-MM') AS year_month,
    COUNT(*) AS total_count
FROM orders
GROUP BY TRUNC(order_date, 'MM')
ORDER BY year_month;

postgres-

SELECT
    to_char(date_trunc('month', order_date), 'YYYY-MM') AS year_month,
    COUNT(*) AS total_count
FROM orders
GROUP BY date_trunc('month', order_date)
ORDER BY year_month;

9. now if we get situtaion where we have to filter on the basis of last 30 days , then the best practise is to
use postgresql INTERVAL clause like 
ques- Write a solution to find the daily active user count for a period of 30 days ending 2019-07-27 inclusively. A user was active on someday if they made at least one activity on that day.
sol-
select activity_date as day,count(distinct(user_id)) as active_users from Activity group by activity_date having activity_date >= DATE '2019-07-27' - INTERVAL '29 days'
and activity_date <='2019-07-27'


10. while using UNION or UNION ALL , keep both queries in brackets ()


11. for finding any Nth largest salary , it is better to use RANK than MAX , we can use MAX for first or second largest
salary but for nth we should use dense_rank() function.

a. RANK() - returns the rank and skips rank number after ties 
eg- RAnk() over(order by scores desc) - that's how we use RANK 
score-Rank
100-1
100-1
90-3   ( 2 is skipped because 1 had ties)
80-4

b. DENSE_RANK() - returns the rank but it doesn't skip number afer ties
eg- DENSE_RANK() over(order by scores desc)
score-Rank
100-1
100-1
90-2
80-3

c. ROW_NUMBER() - always gives a unique number to every entry, even duplicates gets unique numbers.
eg- ROW_NUMBER() over(order by scores desc)
score-Rank
100-1
100-2
90-3 
80-4

now for finding out the nth largest salary-

select salary from 
( select salary,
     dense_rank() over (order by salary desc) as rnk from employees)t
where rnk=n;

where n can be any number.

